
how to arhitect software. model. data vs functional. constraints
compositional

handling enums

handling all errors possible


writing an ORM, worth it
reflection is nice. kind system has limits, but still fairly powerful generics
still, hard after getting used to Haskell. though contraints are sometimes good
becuase you have to stop somewhere. forces a reasonable boundary on kind safety

the model abstraction. how to use abstraction in java. what is abstraction.
abstracting getting/setting values as well as serialization. and connecting them.

java sum refinementIndex
interfaces as constraints

on the value of pretty code.

developing alone. advantages/disadvantages. need more abstraction. can change things a lot


the value of elegant DSLs

the value of constraints and elegant program modeling


how to properly do async functions.

fully flesh out dat model always, this includes errors. this is what actually saves time.
always have exceptions. then don't ever need to have anxiety about testing app. if you see an error, 
you will be able to know exactyl what caused it mos tof the time. this makes programming more efficient
mentally because you don't ahve to feel stressed, can just have fun.


more types is better. dry is not always the best method. kind safety and a clean data model are.
just because something is in common does not make it unelegant. quite the opposite sometimes. 
depends on the inteface.


"stress free programming". spending more time working on good error messages, easy to understand DSLs, 
explicit data structures for solid debugging. then not worry so much aobut perfect code. if it breaks,
it will be easy to fix. and almost easier to develop, because you can go iteratively.


stupid data, smart methods.
data should be simple, structured, explicit, compositional, well-typed, generic.

